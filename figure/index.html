<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StackChan Avatar - HTML 版本</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Microsoft YaHei', sans-serif;
            overflow: hidden;
        }

        #canvas {
            display: block;
            background-color: #000;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90%;
        }

        button {
            padding: 10px 20px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: #333;
            color: #fff;
            transition: all 0.3s;
        }

        button:hover {
            background-color: #555;
        }

        button.active {
            background-color: #4CAF50;
        }

        #status {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 14px;
        }

        #video {
            position: fixed;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            opacity: 0;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="status">加载中...</div>
    <div id="controls">
        <button data-emotion="normal" class="active">正常</button>
        <button data-emotion="angry">生气</button>
        <button data-emotion="happy">开心</button>
        <button data-emotion="love">爱心</button>
        <button data-emotion="wink">Wink</button>
        <button data-emotion="snowflake">雪花屏</button>
    </div>
    <video id="video" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <script>
        class StackChanAvatar {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.video = document.getElementById('video');
                this.statusEl = document.getElementById('status');

                this.eyeRadius = 35;
                this.baseEyeCenterLeft = { x: 150, y: 150 };
                this.baseEyeCenterRight = { x: 250, y: 150 };
                this.eyeCenterLeft = { ...this.baseEyeCenterLeft };
                this.eyeCenterRight = { ...this.baseEyeCenterRight };

                this.faceOffsetX = 0;
                this.faceOffsetY = 0;
                this.targetFaceX = 0;
                this.targetFaceY = 0;
                this.baseFaceRect = { x: 80, y: 50, width: 240, height: 200 };

                this.isBlinking = false;
                this.blinkStep = 0;
                this.faceDetected = false;
                this.eyeMoveScale = 1.5;

                this.currentEmotion = 'normal';
                this.emotionStep = 0;
                this.manualMode = false;

                this.floatingHearts = [];
                this.isSnowflake = false;
                this.snowflakeNoise = null;
                this.snowflakeIntensity = 0.5;

                this.isWink = false;
                this.winkPhase = 0;
                this.randomEmotionInterval = null;

                this.initCanvas();
                this.initButtons();
                this.initKeyEvents();
                this.initBlinkTimer();
                this.initRandomEmotionTimer();
                this.startAnimation();
                this.initFaceDetection();
            }

            initCanvas() {
                this.canvas.width = 400;
                this.canvas.height = 300;
            }

            initButtons() {
                const buttons = document.querySelectorAll('button[data-emotion]');
                buttons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.manualMode = true;
                        buttons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.setEmotion(btn.dataset.emotion);
                    });
                });
            }

            initKeyEvents() {
                window.addEventListener('keydown', (e) => {
                    const key = e.key;
                    const buttons = document.querySelectorAll('button[data-emotion]');
                    
                    if (key === '1') {
                        this.manualMode = true;
                        buttons.forEach(b => b.classList.remove('active'));
                        document.querySelector('button[data-emotion="normal"]').classList.add('active');
                        this.setEmotion('normal');
                    } else if (key === '2') {
                        this.manualMode = true;
                        buttons.forEach(b => b.classList.remove('active'));
                        document.querySelector('button[data-emotion="angry"]').classList.add('active');
                        this.setEmotion('angry');
                    } else if (key === '3') {
                        this.manualMode = true;
                        buttons.forEach(b => b.classList.remove('active'));
                        document.querySelector('button[data-emotion="happy"]').classList.add('active');
                        this.setEmotion('happy');
                    } else if (key === '4') {
                        this.manualMode = true;
                        buttons.forEach(b => b.classList.remove('active'));
                        document.querySelector('button[data-emotion="love"]').classList.add('active');
                        this.setEmotion('love');
                    } else if (key === '5') {
                        this.manualMode = true;
                        buttons.forEach(b => b.classList.remove('active'));
                        document.querySelector('button[data-emotion="wink"]').classList.add('active');
                        this.setEmotion('wink');
                    } else if (key === '6') {
                        this.manualMode = true;
                        buttons.forEach(b => b.classList.remove('active'));
                        document.querySelector('button[data-emotion="snowflake"]').classList.add('active');
                        this.setEmotion('snowflake');
                    } else if (key.toLowerCase() === 'a') {
                        this.manualMode = !this.manualMode;
                        if (!this.manualMode) {
                            buttons.forEach(b => b.classList.remove('active'));
                            document.querySelector('button[data-emotion="normal"]').classList.add('active');
                            this.setEmotion('normal');
                        }
                    } else if (key === ' ') {
                        this.manualMode = false;
                        buttons.forEach(b => b.classList.remove('active'));
                        document.querySelector('button[data-emotion="normal"]').classList.add('active');
                        this.setEmotion('normal');
                    }
                });
            }

            initBlinkTimer() {
                setInterval(() => {
                    if (!this.isBlinking && this.currentEmotion !== 'wink' && this.currentEmotion !== 'love' && this.currentEmotion !== 'snowflake') {
                        this.isBlinking = true;
                        this.blinkStep = 0;
                    }
                }, 4000);
            }

            initRandomEmotionTimer() {
                setInterval(() => {
                    this.randomEmotion();
                }, 10000);
            }

            randomEmotion() {
                if (this.manualMode) {
                    return;
                }

                if (this.currentEmotion !== 'normal') {
                    return;
                }

                const emotions = ['happy', 'angry', 'love', 'wink', 'snowflake'];
                const newEmotion = emotions[Math.floor(Math.random() * emotions.length)];
                this.setEmotion(newEmotion);
            }

            setEmotion(emotion) {
                this.currentEmotion = emotion;
                this.emotionStep = 0;
                this.floatingHearts = [];
                this.isSnowflake = false;

                if (emotion === 'love') {
                    this.startFloatingHearts();
                } else if (emotion === 'snowflake') {
                    this.isSnowflake = true;
                    this.initSnowflakeNoise();
                } else if (emotion === 'wink') {
                    this.isWink = true;
                    this.winkPhase = 0;
                    setTimeout(() => {
                        if (this.currentEmotion === 'wink' && !this.manualMode) {
                            this.setEmotion('normal');
                        }
                    }, 800);
                }

                if (!this.manualMode && emotion !== 'normal') {
                    const durations = {
                        happy: 1000,
                        angry: 1000,
                        love: 7000,
                        wink: 800,
                        snowflake: 5000
                    };
                    if (durations[emotion]) {
                        setTimeout(() => {
                            if (!this.manualMode) {
                                this.setEmotion('normal');
                            }
                        }, durations[emotion]);
                    }
                }
            }

            startFloatingHearts() {
                this.spawnHeartInterval = setInterval(() => {
                    if (this.currentEmotion !== 'love') {
                        clearInterval(this.spawnHeartInterval);
                        return;
                    }
                    this.spawnFloatingHeart();
                }, 150);
            }

            spawnFloatingHeart() {
                const x = Math.random() * (this.canvas.width - 40) + 20;
                const y = this.canvas.height + 20;
                const size = Math.random() * 20 + 15;
                const speed = Math.random() * 2 + 1.5;
                const colorVariant = Math.floor(Math.random() * 3);

                this.floatingHearts.push({
                    x,
                    y,
                    startY: y,
                    size,
                    speed,
                    opacity: 1,
                    swayOffset: Math.random() * 360,
                    swayAmplitude: Math.random() * 15 + 10,
                    rotation: Math.random() * 30 - 15,
                    colorVariant
                });

                if (this.floatingHearts.length > 30) {
                    this.floatingHearts.shift();
                }
            }

            updateFloatingHearts() {
                for (let i = this.floatingHearts.length - 1; i >= 0; i--) {
                    const heart = this.floatingHearts[i];
                    heart.y -= heart.speed;
                    heart.swayOffset += 3;
                    const traveled = heart.startY - heart.y;
                    if (traveled > 100) {
                        heart.opacity = Math.max(0, 1 - (traveled - 100) / 150);
                    }
                    if (heart.y < -50 || heart.opacity <= 0) {
                        this.floatingHearts.splice(i, 1);
                    }
                }
            }

            initSnowflakeNoise() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                this.snowflakeNoise = new Uint8Array(width * height);
                for (let i = 0; i < this.snowflakeNoise.length; i++) {
                    this.snowflakeNoise[i] = Math.floor(Math.random() * 256);
                }
            }

            updateSnowflakeNoise() {
                if (this.isSnowflake && this.snowflakeNoise) {
                    for (let i = 0; i < this.snowflakeNoise.length; i++) {
                        this.snowflakeNoise[i] = Math.floor(Math.random() * 256);
                    }
                }
            }

            initFaceDetection() {
                this.faceDetection = new FaceDetection({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`;
                    }
                });

                this.faceDetection.setOptions({
                    model: 'short',
                    minDetectionConfidence: 0.5
                });

                this.faceDetection.onResults((results) => {
                    this.onFaceResults(results);
                });

                const camera = new Camera(this.video, {
                    onFrame: async () => {
                        await this.faceDetection.send({ image: this.video });
                    },
                    width: 640,
                    height: 480
                });

                camera.start().then(() => {
                    this.statusEl.textContent = '已就绪';
                }).catch((err) => {
                    this.statusEl.textContent = '无法访问摄像头: ' + err.message;
                });
            }

            onFaceResults(results) {
                if (results.detections && results.detections.length > 0) {
                    this.faceDetected = true;
                    const detection = results.detections[0];
                    const bbox = detection.boundingBox;
                    
                    const centerX = bbox.xCenter;
                    const centerY = bbox.yCenter;
                    
                    const normalizedX = -(centerX - 0.5) * 2;
                    const normalizedY = (centerY - 0.5) * 2;
                    
                    const deadZone = 0.03;
                    const finalX = Math.abs(normalizedX) < deadZone ? 0 : normalizedX;
                    const finalY = Math.abs(normalizedY) < deadZone ? 0 : normalizedY;
                    
                    const faceMoveScale = 120;
                    this.targetFaceX = finalX * faceMoveScale;
                    this.targetFaceY = finalY * faceMoveScale;
                    
                    this.statusEl.textContent = '跟踪中';
                } else {
                    this.faceDetected = false;
                    this.targetFaceX = 0;
                    this.targetFaceY = 0;
                    this.statusEl.textContent = '搜索中';
                }
            }

            updateUI() {
                const faceDiffX = Math.abs(this.targetFaceX - this.faceOffsetX);
                const faceDiffY = Math.abs(this.targetFaceY - this.faceOffsetY);

                const faceSmooth = Math.max(faceDiffX, faceDiffY) > 20 ? 0.12 : 0.04;

                this.faceOffsetX = this.faceOffsetX * (1 - faceSmooth) + this.targetFaceX * faceSmooth;
                this.faceOffsetY = this.faceOffsetY * (1 - faceSmooth) + this.targetFaceY * faceSmooth;

                this.eyeCenterLeft.x = this.baseEyeCenterLeft.x + this.faceOffsetX * this.eyeMoveScale;
                this.eyeCenterLeft.y = this.baseEyeCenterLeft.y + this.faceOffsetY * this.eyeMoveScale;
                this.eyeCenterRight.x = this.baseEyeCenterRight.x + this.faceOffsetX * this.eyeMoveScale;
                this.eyeCenterRight.y = this.baseEyeCenterRight.y + this.faceOffsetY * this.eyeMoveScale;

                if (this.isBlinking) {
                    this.blinkStep++;
                    if (this.blinkStep > 6) {
                        this.isBlinking = false;
                        this.blinkStep = 0;
                    }
                }

                if (this.isWink) {
                    this.winkPhase = (this.winkPhase + 1) % 8;
                    if (this.winkPhase === 0 && this.currentEmotion !== 'wink') {
                        this.isWink = false;
                    }
                }

                this.emotionStep = (this.emotionStep + 1) % 8;
            }

            startAnimation() {
                const animate = () => {
                    this.updateUI();
                    this.updateFloatingHearts();
                    this.updateSnowflakeNoise();
                    this.draw();
                    requestAnimationFrame(animate);
                };
                animate();
            }

            draw() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (this.isSnowflake) {
                    this.drawSnowflakeScreen();
                }

                if (this.currentEmotion === 'love') {
                    this.drawFloatingHearts();
                    this.drawLoveEyes();
                } else if (!this.isSnowflake) {
                    this.drawEyes();
                }

                this.drawStatus();
            }

            drawSnowflakeScreen() {
                if (!this.snowflakeNoise) return;

                const width = this.canvas.width;
                const height = this.canvas.height;

                for (let y = 0; y < height; y += 2) {
                    for (let x = 0; x < width; x += 2) {
                        const idx = y * width + x;
                        const gray = this.snowflakeNoise[idx];
                        this.ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                        this.ctx.fillRect(x, y, 2, 2);
                    }
                }
            }

            drawFloatingHearts() {
                const colors = [
                    'rgb(255, 100, 150)',
                    'rgb(255, 150, 180)',
                    'rgb(255, 180, 200)'
                ];

                for (const heart of this.floatingHearts) {
                    this.ctx.save();
                    this.ctx.globalAlpha = heart.opacity;
                    
                    const x = heart.x + Math.sin(heart.swayOffset * Math.PI / 180) * heart.swayAmplitude;
                    this.ctx.translate(x, heart.y);
                    this.ctx.rotate(heart.rotation * Math.PI / 180);
                    
                    this.ctx.fillStyle = colors[heart.colorVariant];
                    this.drawHeart(0, 0, heart.size);
                    
                    this.ctx.restore();
                }
            }

            drawHeart(centerX, centerY, size) {
                this.ctx.beginPath();
                const bottomY = centerY + size * 0.5;
                
                this.ctx.moveTo(centerX, bottomY);
                this.ctx.bezierCurveTo(
                    centerX - size * 0.6, centerY,
                    centerX - size * 0.6, centerY - size * 0.6,
                    centerX, centerY - size * 0.35
                );
                this.ctx.bezierCurveTo(
                    centerX + size * 0.6, centerY - size * 0.6,
                    centerX + size * 0.6, centerY,
                    centerX, bottomY
                );
                this.ctx.fill();
            }

            drawEyes() {
                if (this.isBlinking) {
                    this.drawBlinkEyes();
                } else if (this.currentEmotion === 'angry') {
                    this.drawAngryEyes();
                } else if (this.currentEmotion === 'happy') {
                    this.drawHappyEyes();
                } else if (this.currentEmotion === 'wink') {
                    this.drawWinkEyes();
                } else {
                    this.drawNormalEyes();
                }
            }

            drawNormalEyes() {
                const eyeSize = this.eyeRadius * 1.8;
                this.ctx.fillStyle = '#fff';
                this.drawRoundedRect(this.eyeCenterLeft.x, this.eyeCenterLeft.y, eyeSize, eyeSize, 10);
                this.drawRoundedRect(this.eyeCenterRight.x, this.eyeCenterRight.y, eyeSize, eyeSize, 10);
            }

            drawBlinkEyes() {
                const blinkFactor = Math.max(0.05, 1 - this.blinkStep * 0.16);
                const eyeSize = this.eyeRadius * 1.8;
                this.ctx.fillStyle = '#fff';
                this.drawRoundedRect(this.eyeCenterLeft.x, this.eyeCenterLeft.y, eyeSize, eyeSize * blinkFactor, 10);
                this.drawRoundedRect(this.eyeCenterRight.x, this.eyeCenterRight.y, eyeSize, eyeSize * blinkFactor, 10);
            }

            drawAngryEyes() {
                const eyeSize = this.eyeRadius * 1.8;
                this.ctx.fillStyle = '#fff';
                this.drawRoundedRect(this.eyeCenterLeft.x, this.eyeCenterLeft.y, eyeSize, eyeSize, 10);
                this.drawRoundedRect(this.eyeCenterRight.x, this.eyeCenterRight.y, eyeSize, eyeSize, 10);

                const browWidth = eyeSize * 0.8;
                const browThickness = 6;
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = browThickness;
                this.ctx.lineCap = 'round';

                this.ctx.beginPath();
                this.ctx.moveTo(this.eyeCenterLeft.x - browWidth / 2, this.eyeCenterLeft.y - eyeSize / 2 - 15);
                this.ctx.lineTo(this.eyeCenterLeft.x + browWidth / 2, this.eyeCenterLeft.y - eyeSize / 2 - 5);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(this.eyeCenterRight.x - browWidth / 2, this.eyeCenterRight.y - eyeSize / 2 - 5);
                this.ctx.lineTo(this.eyeCenterRight.x + browWidth / 2, this.eyeCenterRight.y - eyeSize / 2 - 15);
                this.ctx.stroke();
            }

            drawHappyEyes() {
                const eyeSize = this.eyeRadius * 1.8;
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 24;
                this.ctx.lineCap = 'round';

                this.ctx.beginPath();
                this.ctx.arc(this.eyeCenterLeft.x, this.eyeCenterLeft.y, eyeSize / 2, Math.PI, 0, false);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.arc(this.eyeCenterRight.x, this.eyeCenterRight.y, eyeSize / 2, Math.PI, 0, false);
                this.ctx.stroke();
            }

            drawLoveEyes() {
                const heartSize = this.eyeRadius * 2.0;
                this.ctx.fillStyle = 'rgb(255, 50, 80)';
                this.drawHeart(this.eyeCenterLeft.x, this.eyeCenterLeft.y, heartSize);
                this.drawHeart(this.eyeCenterRight.x, this.eyeCenterRight.y, heartSize);
            }

            drawWinkEyes() {
                const eyeSize = this.eyeRadius * 1.8;
                this.ctx.fillStyle = '#fff';
                this.drawRoundedRect(this.eyeCenterLeft.x, this.eyeCenterLeft.y, eyeSize, eyeSize, 10);

                let blinkFactor;
                if (this.winkPhase < 4) {
                    blinkFactor = Math.max(0.05, 1 - this.winkPhase * 0.25);
                } else {
                    blinkFactor = Math.max(0.05, (this.winkPhase - 4) * 0.25);
                }
                this.drawRoundedRect(this.eyeCenterRight.x, this.eyeCenterRight.y, eyeSize, eyeSize * blinkFactor, 10);
            }

            drawRoundedRect(cx, cy, w, h, r) {
                this.ctx.beginPath();
                this.ctx.roundRect(cx - w / 2, cy - h / 2, w, h, r);
                this.ctx.fill();
            }

            drawStatus() {
                this.ctx.fillStyle = this.faceDetected ? '#00ff64' : '#ff6464';
                this.ctx.beginPath();
                this.ctx.arc(14, 14, 4, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.fillStyle = '#fff';
                this.ctx.font = '14px Microsoft YaHei';
                this.ctx.fillText(this.faceDetected ? '跟踪中' : '搜索中', 25, 17);

                const emotionMap = {
                    normal: '正常',
                    angry: '生气',
                    happy: '开心',
                    love: '爱心',
                    wink: 'Wink',
                    snowflake: '雪花屏'
                };
                const emotionText = emotionMap[this.currentEmotion] || '正常';
                const modeText = this.manualMode ? '【手动】' : '【自动】';
                this.ctx.fillText(`${modeText} 表情：${emotionText}`, 25, 32);

                this.ctx.fillStyle = '#969696';
                this.ctx.font = '11px Microsoft YaHei';
                this.ctx.fillText('1-正常 2-生气 3-开心 4-爱心 5-Wink 6-雪花屏', 10, 255);
                this.ctx.fillText('A-切换自动/手动  空格 - 重置为正常', 10, 270);
                this.ctx.fillText('爱心表情有浮动效果', 10, 285);
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            new StackChanAvatar();
        });
    </script>
</body>
</html>
